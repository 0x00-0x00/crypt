#!/usr/bin/env python
# coding:utf-8

import sys
import os
import base64
import shutil
from time import time
from argparse import ArgumentParser, FileType
from shemutils.logger import Logger
from shemutils.encryption import Encryption, RSA
from shemcrypt.integrity import integrity_check
from shemcrypt.configuration import secret_key_file, get_private_key_location
from shemcrypt.time import format_time
from shemcrypt.compression import compress_file, decompress_file
from shemcrypt.shred import shred_file
from sys import exit, stdout, stderr


def import_error(pkg):
    """
    Prints to the screen an error message and informing which package is missing
    :param pkg:
    :return: void
    """
    print("Error: You need to install the package: {0}".format(pkg))
    return

try:
    import shemutils
except ImportError:
    import_error("shemutils")
    exit(-1)

try:
    import gevent
    from gevent.event import Event
except ImportError:
    import_error("gevent")
    exit(-1)

__VERSION__ = '1.9.7'
__author__ = "zc00l"
__revision__ = '2017/03/07'
logger = Logger("CRYPT")


write = stdout.write
flush = stdout.flush
errwrite = stderr.write


def header():
    errwrite("[crypt v. %s\n" % __VERSION__)
    errwrite("revision: %s\n" % __revision__)


class KeyFile(object):
    def __init__(self, fd):
        self.encrypted_data = base64.b64decode(fd.read())
        self.key_location = get_private_key_location()
        self.rsa = RSA()
        if not self.key_location:
            print("Type 'crypt-keygen' to generate a key file.")
            exit(1)
        self.priv_f, self.pub_f = self.key_location + ".priv.key", self.key_location + ".pub.key"
        self.rsa.load_keys(priv_f=self.priv_f, pub_f=self.pub_f)

    def _decrypt_key(self):
        return self.rsa.decrypt_message(self.encrypted_data)

    def get(self):
        return Encryption.hash256(self._decrypt_key())


class Crypter(object):
    """
    Main class
    """
    def __init__(self, args):
        self.verbose = args.verbose

        '# Files options'
        self.file = args.file
        self.ffiles = set()

        '# Msg option'
        self.msg = args.msg

        '# Key size'
        self.key_bits = args.bits

        '# Integrity disable '
        self.no_integrity = args.no_check

        '# Compression boolean '
        self.compress = args.compress

        '# Unique option'
        self.unique = Event()
        if args.unique is True:
            self.unique.set()

        '# Mode option'
        self.mode = [args.encrypt, args.decrypt]
        if not self._do_parsing():
            logger.critical("Validation error")
            exit(1)
        if args.keyfile is not False:
            '# RSA Key file generated by crypt-keygen '
            keyfile = KeyFile(open(secret_key_file, "rb"))
            self.key = keyfile.get()
        else:
            '# Standard mode -> Password Hashing '
            self.key = Encryption.get_key(self.key_bits)

        '# Program start'
        if self.file is not None:
            '# Means output will be file'
            if self.mode[0] is True:
                self._do_encrypt_files()
                return
            elif self.mode[1] is True:
                self._do_decrypt_files()
                return

        if self.msg is not None:
            '# Means output will be message '
            if self.mode[0] is True:
                logger.info("Cipher: ")

                #  Read from stdin if - is passed to argument.
                if self.msg == "-":
                    self.msg = sys.stdin.read()

                write(self._do_encrypt_message().decode(sys.stdout.encoding))
                return
            elif self.mode[1] is True:
                logger.info("Message: ")
                write(self._do_decrypt_message() + "\n")
                return

    def _do_encrypt_message(self):
        iv = Encryption.create_iv()
        cipher = Encryption.encrypt_message(self.msg, self.key, iv)
        cipher64 = base64.b64encode(cipher)
        return cipher64

    def _do_decrypt_message(self):
        decoded_cipher = base64.b64decode(self.msg)
        plaintext = Encryption.decrypt_message(decoded_cipher, self.key)
        return plaintext

    def _do_encrypt_files(self):
        logger.info("Starting encryption procedure ...")
        t = len(self.ffiles)  # num of files
        j = []
        k1 = time()

        for f in self.ffiles:
            '# Create initialization vector'
            iv = Encryption.create_iv()

            if self.compress is True:
                #  Compress the file and return its path
                compressed_file = compress_file(f.name)

                #  Encrypt the data
                g = gevent.spawn(Encryption.encrypt_file, compressed_file, self.key, iv)
                g.join()

                #  Generate the encrypted (and compressed) data file name
                encrypted_file = compressed_file + '.enc'

                #  Move the encrypted data to the working directory.
                try:
                    shutil.move(encrypted_file, os.getcwd())
                except shutil.Error:
                    shred_file(os.getcwd() + os.sep + os.path.basename(encrypted_file))
                    shutil.move(encrypted_file, os.getcwd())

                #  Shred the compressed data.
                if shred_file(compressed_file) == 0:
                    if not os.path.exists(compressed_file):
                        logger.step_ok("File shredded: '{0}\n".format(os.path.abspath(compressed_file)))
            else:
                '# Start an encryption greenlet '
                g = gevent.spawn(Encryption.encrypt_file, f.name, self.key, iv)
                '# Add it to job queue '
                j.append(g)

            '# Return information to the user that encryption function has started'
            if self.verbose:
                logger.info("Encryption of file '{0}' started.\n".format(f.name))

        if len(j) > 0:
            gevent.joinall(j)
        logger.info("Encryption procedure has been completed.\n")

        if self.no_integrity is not True:
            logger.info("Checking integrity of files ...")
            for f in self.ffiles:
                encrypted_name = f.name + ".enc"
                if integrity_check(f.name, encrypted_name, self.key) != 0:
                    logger.error("File '{0}' has failed for integrity check.")
            logger.info("Integrity check has been completed.\n")
        else:
            logger.info("Skipping integrity check.")

        if self.unique.is_set():
            logger.info("Deleting files ...")  # why not gevent??????
            for f in self.ffiles:
                if shred_file(f.name) == 0:
                    if not os.path.exists(f.name):
                        logger.step_ok("File deleted: '{0}\n".format(os.path.abspath(f.name)))
        k2 = time()
        logger.info("Total time elapsed: {0}".format(format_time(k2-k1)))
        if t > 1:
            logger.info("Time mean: %.2f" % (format_time((k2-k1)/float(t))))
        return 0, 0

    def _do_decrypt_files(self):
        logger.info("Starting decryption procedure ...")
        j = []
        t = len(self.ffiles)
        k1 = time()

        for f in self.ffiles:

            if self.compress is True:
                #  Decrypt the data
                g = gevent.spawn(Encryption.decrypt_file, f.name, self.key)
                g.join()

                #  Unencrypted file name
                unencrypted_name, ext = os.path.splitext(f.name)

                #  Decompress the file and return its path
                decompressed_file = decompress_file(unencrypted_name)

                #  Move the decrypted data (and decompressed) to the working directory.
                try:
                    shutil.move(decompressed_file, os.getcwd())
                except shutil.Error:
                    shred_file(os.getcwd() + os.sep + os.path.basename(decompressed_file))
                    shutil.move(decompressed_file, os.getcwd())

            else:
                '# Spawn new decryption thread'
                g = gevent.spawn(Encryption.decrypt_file, f.name, self.key)

                '# Append greenlet to group'
                j.append(g)

            '# Returns information to the user '
            if self.verbose:
                logger.info("Decryption of file '{0}' started.".format(f.name))

        if len(j) > 0:
            '# Wait for greenlet to finish.'
            gevent.joinall(j)

        logger.info("Decryption procedure has been completed.\n")

        if self.unique.is_set():
            logger.info("Deleting files ...")
            for f in self.ffiles:
                shred_file(f.name)
                if not os.path.exists(f.name):
                    logger.info("File deleted: '{0}'".format(os.path.abspath(f.name)))
                else:
                    logger.warning("File not deleted: '{0}'\n".format(os.path.abspath(f.name)))

        k2 = time()
        logger.info("Total time elapsed: {0}".format(format_time(k2-k1)))
        if t > 1:
            logger.info("Time mean: %s" % (format_time((k2-k1)/float(t))))
        return 0, 0

    def _count_files(self):
        x = len(self.ffiles)
        if self.verbose:
            logger.info("%d files were selected." % x)
        return x

    def _check_for_decryption(self):
        for x in self.file:
            f, e = os.path.splitext(x.name)
            b = os.path.basename(x.name)
            if e != ".enc":
                logger.warning("File '{0}' is not encrypted.".format(b))
            else:
                self.ffiles.add(x)

    def _check_for_encryption(self):
        for x in self.file:
            f, e = os.path.splitext(x.name)
            b = os.path.basename(x.name)
            if e == ".enc":
                logger.warning("File '{0}' is already encrypted.".format(b))
            else:
                self.ffiles.add(x)

    def _do_parsing(self):
        var = self._parse_options()
        if var[0] is False:
            return False
        if var[1] is False:
            return False
        return True

    def _parse_options(self):

        error_flag = [False, False]
        stats_flag = [False, False]

        "# This if conditional checks for a valid combination of arguments"
        if self.mode[0] is False and self.mode[1] is False:
            logger.warning("Neither --encrypt or --decrypt were set.")
            logger.error("No mode of operation was set.")
            return error_flag
        elif self.mode[0] is True and self.mode[1] is True:
            logger.warning("Both --encrypt e --decrypt were set.")
            logger.error("Only one operation mode must be set.")
            return error_flag
        elif self.mode[0] is True:
            logger.info("Operation mode set to: Encryption")
            stats_flag[0] = True
        elif self.mode[1] is True:
            logger.info("Operation mode set to: Decryption")
            stats_flag[0] = True

        "# This conditional checks if file or message"
        if self.file is None and self.msg is None:
            logger.warning("No output option was set.")
            logger.error("A valid output set is needed (--file ou --msg)")
            return error_flag
        elif self.file is not None and self.msg is not None:
            logger.warning("Both output options were set.")
            logger.error("Only one output option must be set.")
            return error_flag
        elif self.file is not None:
            logger.info("Output option set to: File")
            if len(self.file) < 1:
                logger.warning("No file mentioned.")
                return error_flag
            if self.mode[0] is True:  # encriptação
                self._check_for_encryption()
            elif self.mode[1] is True:
                self._check_for_decryption()
            self._count_files()
            stats_flag[1] = True
        elif self.msg is not None:
            logger.info("Output option set to: Message")
            if len(self.msg) < 1:
                return error_flag
            stats_flag[1] = True
        return stats_flag


def main():
    header()
    t1 = time()

    parser = ArgumentParser()

    core_group = parser.add_argument_group("CORE")
    file_group = parser.add_argument_group("FILE")
    mesg_group = parser.add_argument_group("MESG")

    core_group.add_argument("--encrypt", dest="encrypt", action="store_true", help="Set operation mode to Encryption")
    core_group.add_argument("--decrypt", dest="decrypt", action="store_true", help="Set operation mode to Decryption")
    core_group.add_argument("-b", "--bits", help="Key size in bits. Options: 128, 256", default=256, type=int)
    core_group.add_argument("-v", "--verbose", help="Verbose mode.", action="store_true")
    core_group.add_argument("-u", "--unique", help="Removes encrypted file when decrypts, remove unencrypted file"
                                                   " when encrypting", action="store_true")
    core_group.add_argument("-k", "--keyfile", action="store_true", help="Secret Key File to use instead "
                                                                         "of password hashing.")
    core_group.add_argument("-nc", "--no-check", action="store_true",
                            help="Disables integrity check of encrypted files.")
    core_group.add_argument("-c", "--compress", action="store_true",
                            help="Compress/decompress the data before encryption.")
    file_group.add_argument("-f", "--file", help="File to be de/encrypted.", nargs='+', type=FileType('rb+'))
    mesg_group.add_argument("-m", "--msg", help="Message to be de/encrypted")

    args = parser.parse_args()

    Crypter(args)

    t2 = time()

    if args.verbose:
        print("Process duration: %.2f seconds" % format_time(float(float(t2) - float(t1))))

    return

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        m = Logger("MAIN")
        m.critical("Interrupt signal detected.")
        exit(0)
