#!/usr/bin/env python
# coding:utf-8

from time import time
from argparse import ArgumentParser, FileType
import os

from sys import exit, stdout

try:
    import shemutils
except ImportError:
    print "Erro: Você precisa instalar o módulo shemutils para utilizar esse programa."
    exit(-1)

try:
    import gevent
    from gevent.event import Event
except ImportError:
    print "Erro: Voce precisa instalar o modulo gevent para utilizar esse programa."
    exit(-1)

__VERSION__ = 1.6
__author__ = "shemhazai"
__revision__ = "2016/11/09"
shredlogger = shemutils.Logger("Shred")


def shred_file(f, r="/dev/urandom", n=2):
    """
    Shred a file in a really tight secure manner
    :param f: string containing file name
    :param r: string containing random generator file
    :param n: int containing number of passes
    :return: 0 if successful
    """
    '# Get file size in bytes'
    file_size = os.path.getsize(f)
    if file_size < 0:
        return None

    '# Get random generator file handle '
    randfd = open(r)
    patterns = [randfd.read(1) for x in xrange(n)]
    randfd.close()

    x = 1  # count passes

    '# Open file handle'
    with open(f, "wb+") as fd:
        for p in patterns:

            '# Overwrite data with random pattern byte '
            for y in xrange(file_size):
                fd.write(p)
            shredlogger.info("Shred pass #{0} using byte '{1}' done for file '{2}'".format(x, p, f))
            x += 1

        lpb = '\x00'
        for y in xrange(file_size):
            fd.write(lpb)
        shredlogger.info("Shred pass #{0} using byte '{1}' done for file '{2}'".format(x, lpb, f))

    os.remove(f)  # deletes file from OS
    return 0


def format_time(t):
    days = 0.0
    hours = 0.0
    minutes = 0.0
    if t > 86400:
        days = (t / 86400)
        hours = (t % 86400) / 3600
        minutes = (t % 3600) / 60
        seconds = ((t % 86400) % 3600) % 60
    elif t > 3600:
        hours = (t / 3600.0)
        minutes = ((t % 3600) / 60)
        seconds = ((t % 3600) % 60)
    elif t > 60:
        minutes = (t / 60)
        seconds = (t % 60)
    else:
        seconds = t

    return "%dd %2.fh %2.fm %2.fs" % (days, hours, minutes, seconds)


write = stdout.write
flush = stdout.flush


def header():
    print "[shemcrypt v. %.2f]" % __VERSION__
    print "revision: %s" % __revision__


class Crypter(object):
    """
    Main class
    """
    def __init__(self, args):
        self.logger = shemutils.Logger("CRYPT")
        self.verbose = args.verbose

        '# Files options'
        self.file = args.file
        self.ffiles = set()

        '# Msg option'
        self.msg = args.msg

        '# Key size'
        self.key_bits = args.bits

        '# Unique option'
        self.unique = Event()
        if args.unique is True:
            self.unique.set()

        '# Mode option'
        self.mode = [args.encrypt, args.decrypt]
        if not self._do_parsing():
            self.logger.critical("Erro de validação.")
            exit(1)
        self.key = shemutils.Encryption.get_key(self.key_bits)

        '# Inicia o programa'
        if self.file is not None:
            '# Significa que o método de saída é de arquivos '
            if self.mode[0] is True:
                self._do_encrypt_files()
            elif self.mode[1] is True:
                self._do_decrypt_files()

        if self.msg is not None:
            '# Significa que o método de saída é de mensagens. '
            if self.mode[0] is True:
                self.logger.info("Cifra: ")
                write(self._do_encrypt_message())
            elif self.mode[1] is True:
                self.logger.info("Mensagem: ")
                write(self._do_decrypt_message() + "\n")

    def _do_encrypt_message(self):
        iv = shemutils.Encryption.create_iv()
        cipher = shemutils.Encryption.encrypt_message(self.msg, self.key, iv)
        return cipher.encode("base64")

    def _do_decrypt_message(self):
        decoded_cipher = self.msg.decode("base64")
        plaintext = shemutils.Encryption.decrypt_message(decoded_cipher, self.key)
        return plaintext

    def _do_encrypt_files(self):
        self.logger.info("Iniciando procedimento de cifragem ...")
        d = 0  # done variable
        e = 0  # errors variable
        t = len(self.ffiles)  # num of files
        j = []
        k1 = time()

        for f in self.ffiles:
            '# Create initialization vector'
            iv = shemutils.Encryption.create_iv()

            '# Spawns a greenlet.'
            g = gevent.spawn(shemutils.Encryption.encrypt_file, f.name, self.key, iv)

            '# Append Greenlet to Greenlet Group'
            j.append(g)

            '# Return information to the user that encryption function has started'
            if self.verbose:
                self.logger.info("Cifragem do arquivo '{0}' iniciada.".format(f.name))
                print ""

        '# Waits for encryption to finish.'
        gevent.joinall(j)
        self.logger.info("Procedimento de cifragem completo.")

        if self.unique.is_set():
            print ""
            self.logger.info("Removendo arquivos ...")
            for f in self.ffiles:
                if shred_file(f.name) == 0:
                    if not os.path.exists(f.name):
                        self.logger.step_ok("Remocao de arquivo '{0}".format(os.path.abspath(f.name)))
                    print ""

        k2 = time()
        self.logger.info("Tempo total gasto: {0}".format(format_time(k2-k1)))
        if t > 1:
            self.logger.info("Media de tempo gasto entre arquivos: %.2f" % ((k2-k1)/float(t)))
        return d, e

    def _do_decrypt_files(self):
        self.logger.info("Iniciando procedimento de decifragem ...")
        d = 0  # done variable
        e = 0  # errors variable
        j = []
        t = len(self.ffiles)
        k1 = time()

        for f in self.ffiles:
            '# Spawn new decryption thread'
            g = gevent.spawn(shemutils.Encryption.decrypt_file, f.name, self.key)

            '# Append greenlet to group'
            j.append(g)

            '# Returns information to the user '
            if self.verbose:
                self.logger.info("Decifragem do arquivo '{0}' iniciada.".format(f.name))

        '# Wait for greenlet to finish.'
        gevent.joinall(j)
        self.logger.info("Procedimento de decifragem completo.")

        if self.unique.is_set():
            print ""
            self.logger.info("Removendo arquivos ...")
            for f in self.ffiles:
                os.remove(f.name)
                if not os.path.exists(f.name):
                    self.logger.info("Arquivo '{0}' removido.".format(os.path.abspath(f.name)))
                else:
                    self.logger.warning("Arquivo '{0}' nao foi removido.".format(os.path.abspath(f.name)))
                print ""

        k2 = time()
        self.logger.info("Tempo total gasto: {0}".format(k2-k1))
        if t > 1:
            self.logger.info("Media de tempo gasto entre arquivos: %.2f" % ((k2-k1)/float(t)))
        return d, e

    def _count_files(self):
        x = len(self.ffiles)
        if self.verbose:
            self.logger.info("%d arquivos foram selecionados." % x)
        return x

    def _check_for_decryption(self):
        for x in self.file:
            f, e = os.path.splitext(x.name)
            b = os.path.basename(x.name)
            if e != ".enc":
                self.logger.warning("Arquivo '{0}' não está encriptografado.".format(b))
            else:
                self.ffiles.add(x)

    def _check_for_encryption(self):
        for x in self.file:
            f, e = os.path.splitext(x.name)
            b = os.path.basename(x.name)
            if e == ".enc":
                self.logger.warning("Arquivo {0} já está criptografado.".format(b))
            else:
                self.ffiles.add(x)

    def _do_parsing(self):
        var = self._parse_options()
        if var[0] is False:
            return False
        if var[1] is False:
            return False
        return True

    def _parse_options(self):
        """
        Essa função fará o parsing das opções.
        A função retornará uma lista de duas booleans que indicarão
        o estado das flags de checagem.
        Não se admite erro em nenhuma etapa de checagem, portanto
        por conta disso, a variável ERROR_FLAG é uma lista de duas
        booleans falsas que servirá de retorno para quando a checa-
        gem de lógicas inválidas forem detectadas.
        :return:
        """

        error_flag = [False, False]
        stats_flag = [False, False]

        "# This if conditional checks for a valid combination of arguments"
        if self.mode[0] is False and self.mode[1] is False:
            self.logger.warning("Nem --encrypt ou --decrypt foram definidos.")
            self.logger.error("É necessário definir um modo de operação!")
            return error_flag
        elif self.mode[0] is True and self.mode[1] is True:
            self.logger.warning("Ambos --encrypt e --decrypt foram definidos.")
            self.logger.error("Só se admite a definição de um modo de operação!")
            return error_flag
        elif self.mode[0] is True:
            self.logger.info("Modo de operação definido: Encriptação")
            stats_flag[0] = True
        elif self.mode[1] is True:
            self.logger.info("Modo de operação definido: Decriptação")
            stats_flag[0] = True

        "# Essa condicional checa as opções de saída (arquivo ou mensagem)"
        if self.file is None and self.msg is None:
            self.logger.warning("Nenhuma opção de saída foi definida!")
            self.logger.error("É necessário definir uma opção de saída! (--file ou --msg)")
            return error_flag
        elif self.file is not None and self.msg is not None:
            self.logger.warning("Ambas opções de saídas foram definidas.")
            self.logger.error("Só se admite a definição de uma opção de saída.")
            return error_flag
        elif self.file is not None:
            self.logger.info("Modo de saída definido: Arquivo")
            if len(self.file) < 1:
                self.logger.warning("Nenhum arquivo foi mencionado.")
                return error_flag
            if self.mode[0] is True:  # encriptação
                self._check_for_encryption()
            elif self.mode[1] is True:
                self._check_for_decryption()
            self._count_files()
            stats_flag[1] = True
        elif self.msg is not None:
            self.logger.info("Modo de saída definido: Mensagem")
            if len(self.msg) < 1:
                return error_flag
            stats_flag[1] = True
        return stats_flag


def main():
    header()
    t1 = time()

    parser = ArgumentParser()

    core_group = parser.add_argument_group("CORE")
    file_group = parser.add_argument_group("FILE")
    mesg_group = parser.add_argument_group("MESG")

    core_group.add_argument("--encrypt", dest="encrypt", action="store_true", help="Opera em modo Cifragem")
    core_group.add_argument("--decrypt", dest="decrypt", action="store_true", help="Opera em modo Decifragem")
    core_group.add_argument("-b", "--bits", help="Tamanho da chave em bits. Opções: 128, 256", default=256, type=int)
    core_group.add_argument("-v", "--verbose", help="Ativa ou desativa o modo verbose.", action="store_true")
    core_group.add_argument("-u", "--unique", help="Removes encrypted file when decrypts, remove unencrypted file"
                                                   " when encrypting", action="store_true")
    file_group.add_argument("-f", "--file", help="Arquivo a ser cifrado ou decifrado.", nargs='+', type=FileType('rb+'))
    mesg_group.add_argument("-m", "--msg", help="Mensagem a ser cifrada ou decifrada.")

    args = parser.parse_args()

    Crypter(args)

    t2 = time()

    if args.verbose:
        print "Duração do processo: %.2f segundos" % float(float(t2) - float(t1))

    return

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        m = shemutils.Logger("MAIN")
        m.critical("Interrupt signal detected.")
        exit(0)
